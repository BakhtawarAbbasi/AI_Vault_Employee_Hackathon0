import os
import time
from datetime import datetime

def get_existing_files_in_needs_action():
    """Get a set of filenames that already have task files in Needs_Action"""
    task_files = set()

    # Check if Needs_Action folder exists, create if it doesn't
    if not os.path.exists("Needs_Action"):
        print("Needs_Action folder not found. Creating it...")
        os.makedirs("Needs_Action")
        return task_files  # Return empty set since folder was just created

    try:
        for filename in os.listdir("Needs_Action"):
            if filename.endswith(".md"):
                # Read the task file to get the original filename
                with open(os.path.join("Needs_Action", filename), 'r') as f:
                    content = f.read()
                    # Look for the filename in the YAML header
                    for line in content.split('\n'):
                        if line.startswith('filename:'):
                            original_filename = line.split(':', 1)[1].strip()
                            task_files.add(original_filename)
                    # Also check for the new format with # Review File:
                    for line in content.split('\n'):
                        if line.startswith('# Review File:'):
                            original_filename = line.split(':', 1)[1].strip()
                            task_files.add(original_filename)
    except Exception as e:
        # Log error if there's an issue reading the Needs_Action folder
        log_error(f"Error reading Needs_Action folder: {e}")

    return task_files

def create_task_file(original_filename):
    """Create a task file in Needs_Action folder"""
    try:
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        # Create the Needs_Action folder if it doesn't exist
        if not os.path.exists("Needs_Action"):
            print("Needs_Action folder not found. Creating it...")
            os.makedirs("Needs_Action")

        # Create a unique task filename based on the original filename
        task_filename = f"task_{original_filename.replace('.', '_')}.md"
        task_path = os.path.join("Needs_Action", task_filename)

        # Create the task file content using the new template
        task_content = f"""---
type: file_review
status: pending
priority: medium
created_at: {timestamp}
related files: [Inbox/{original_filename}]
---

# Review File: {original_filename}

## Description
A new file was added to the Inbox folder that requires review and action. Review the content and determine the appropriate next steps.

## Checklist
- [ ] Review the content of {original_filename}
- [ ] Determine appropriate action based on content
- [ ] Execute required action or delegate appropriately

## Notes
File location: Inbox/{original_filename}
This task was automatically generated by the file watcher.
"""

        # Write the task file
        with open(task_path, 'w') as f:
            f.write(task_content)

        print(f"Created task file for: {original_filename}")

    except Exception as e:
        # If there's an error creating the task file, log it
        log_error(f"Error creating task file for {original_filename}: {e}")

def log_error(error_message):
    """Write error message to log file with timestamp"""
    try:
        # Create Logs folder if it doesn't exist
        if not os.path.exists("Logs"):
            os.makedirs("Logs")

        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] {error_message}\n"

        # Write error to watcher_error.log
        with open("Logs/watcher_error.log", 'a') as log_file:
            log_file.write(log_entry)

        # Also print to console so user sees the error
        print(f"ERROR LOGGED: {error_message}")
    except Exception as e:
        # If we can't even log the error, print to console
        print(f"CRITICAL ERROR - Could not log error: {error_message}. Logging failed: {e}")

def main():
    """Main function that runs the file watcher"""
    print("Starting file watcher...")
    print("Monitoring Inbox folder for new files...")

    # Create required folders if they don't exist
    if not os.path.exists("Inbox"):
        print("Inbox folder not found. Creating it...")
        os.makedirs("Inbox")

    if not os.path.exists("Needs_Action"):
        print("Needs_Action folder not found. Creating it...")
        os.makedirs("Needs_Action")

    # Keep track of files we've already processed
    processed_files = set()

    # Get any files that are already in the Inbox
    if os.path.exists("Inbox"):
        try:
            processed_files = set(os.listdir("Inbox"))
            print(f"Initial files in Inbox: {processed_files}")
        except Exception as e:
            log_error(f"Error reading Inbox folder: {e}")
            processed_files = set()
    else:
        print("Inbox folder not found. Creating it...")
        os.makedirs("Inbox")

    # Get existing tasks to avoid duplicates
    existing_tasks = get_existing_files_in_needs_action()
    processed_files.update(existing_tasks)

    try:
        while True:
            # Check if Inbox folder exists and create if necessary
            if not os.path.exists("Inbox"):
                print("Inbox folder not found. Creating it...")
                os.makedirs("Inbox")

            # Check if Needs_Action folder exists and create if necessary
            if not os.path.exists("Needs_Action"):
                print("Needs_Action folder not found. Creating it...")
                os.makedirs("Needs_Action")

            # Get current files in Inbox
            try:
                current_files = set(os.listdir("Inbox"))
            except Exception as e:
                log_error(f"Error accessing Inbox folder: {e}")
                current_files = set()

            # Find new files that we haven't processed yet
            new_files = current_files - processed_files

            # Process each new file
            for new_file in new_files:
                if new_file not in existing_tasks:  # Avoid duplicate task creation
                    print(f"New file detected: {new_file}")
                    create_task_file(new_file)
                    existing_tasks.add(new_file)

            # Update the processed files set
            processed_files = current_files

            # Wait 5 seconds before checking again
            time.sleep(5)

    except KeyboardInterrupt:
        print("\nFile watcher stopped by user.")
    except Exception as e:
        # This is the main error handler that prevents the script from crashing
        log_error(f"Unexpected error in main loop: {e}")
        print(f"An error occurred: {e}")
        # The script would continue running if we put a loop here,
        # but for now we'll just log and exit gracefully
        # In a production system, you might want to restart the watcher here

if __name__ == "__main__":
    main()